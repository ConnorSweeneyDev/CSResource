#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdlib>
#include <exception>
#include <execution>
#include <filesystem>
#include <format>
#include <iostream>
#include <mutex>
#include <string>
#include <utility>
#include <vector>

#include "SDL3/SDL_init.h"
#include "SDL3/SDL_iostream.h"
#include "SDL3/SDL_stdinc.h"
#include "SDL3_shadercross/SDL_shadercross.h"
#include "stb_image.h"

#include "exception.hpp"
#include "state.hpp"
#include "utility.hpp"

int try_main(int argc, char *argv[])
{
  csr::base::state state(argc, argv);

  try
  {
    std::filesystem::create_directories(state.output_shader_directory);
    std::filesystem::create_directories(state.output_include_directory);
    std::filesystem::create_directories(state.output_source_directory);
  }
  catch (const std::exception &error)
  {
    std::string directories =
      std::format("[{}, {}, {}]", state.output_shader_directory.string(), state.output_include_directory.string(),
                  state.output_source_directory.string());
    throw csr::utility::exception("Failed to create output directories " + directories + ": " +
                                  std::string(error.what()));
  }

  if (!SDL_ShaderCross_Init()) throw csr::utility::sdl_exception("Failed to initialize shadercross");

  std::string include_content = "// This file is automatically generated, do not edit manually.\n\n"
                                "#pragma once\n\n"
                                "#include <vector>\n\n"
                                "namespace cse::resource\n"
                                "{\n"
                                "  struct compiled_shader\n"
                                "  {\n"
                                "    const std::vector<unsigned char> dxil = {};\n"
                                "    const std::vector<unsigned char> spirv = {};\n"
                                "  };\n"
                                "  struct compiled_texture\n"
                                "  {\n"
                                "    const std::vector<unsigned char> data = {};\n"
                                "    const int width = 0;\n"
                                "    const int height = 0;\n"
                                "    const int channels = 0;\n"
                                "  };\n\n";
  std::string source_content = "// This file is automatically generated, do not edit manually.\n\n"
                               "#include \"resource.hpp\"\n\n"
                               "namespace cse::resource\n"
                               "{\n";
  std::vector<std::exception_ptr> exceptions;
  std::mutex exceptions_mutex;
  std::mutex io_mutex;
  std::for_each(
    std::execution::par, state.resources.begin(), state.resources.end(),
    [&state, &exceptions, &exceptions_mutex, &io_mutex](csr::base::resource &resource)
    {
      if (resource.type == csr::base::resource::INVALID)
      {
        std::lock_guard<std::mutex> lock(exceptions_mutex);
        exceptions.emplace_back(std::make_exception_ptr(
          csr::utility::exception("Invalid resource type for resource: {}", resource.path.string())));
        return;
      }

      if (resource.type == csr::base::resource::SHADER)
      {
        size_t file_size = 0;
        char *file_data = reinterpret_cast<char *>(SDL_LoadFile(resource.path.string().c_str(), &file_size));
        if (!file_data)
        {
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(
            std::make_exception_ptr(csr::utility::sdl_exception("Failed to load shader {}", resource.path.string())));
          return;
        }

        SDL_ShaderCross_HLSL_Info hlsl_info = {reinterpret_cast<char *>(file_data),
                                               "main",
                                               nullptr,
                                               nullptr,
                                               resource.path.extension() == ".vert"
                                                 ? SDL_SHADERCROSS_SHADERSTAGE_VERTEX
                                                 : SDL_SHADERCROSS_SHADERSTAGE_FRAGMENT,
                                               false,
                                               nullptr,
                                               0};

        size_t compiled_dxil_size = 0;
        Uint8 *compiled_dxil_shader =
          reinterpret_cast<Uint8 *>(SDL_ShaderCross_CompileDXILFromHLSL(&hlsl_info, &compiled_dxil_size));
        if (!compiled_dxil_shader)
        {
          SDL_free(file_data);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(std::make_exception_ptr(
            csr::utility::sdl_exception("Failed to compile dxil shader {}", resource.path.string())));
          return;
        }
        SDL_IOStream *dxil_output = nullptr;
        {
          std::lock_guard<std::mutex> lock(io_mutex);
          dxil_output = SDL_IOFromFile(
            (state.output_shader_directory / resource.path.filename()).string().append(".dxil").c_str(), "w");
        }
        if (!dxil_output)
        {
          SDL_free(file_data);
          SDL_free(compiled_dxil_shader);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(std::make_exception_ptr(
            csr::utility::sdl_exception("Failed to open dxil output file for shader {}", resource.path.string())));
          return;
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (SDL_WriteIO(dxil_output, compiled_dxil_shader, compiled_dxil_size) != compiled_dxil_size)
          {
            SDL_free(file_data);
            SDL_free(compiled_dxil_shader);
            SDL_CloseIO(dxil_output);
            std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to write dxil output file for shader {}", resource.path.string())));
            return;
          }
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (!SDL_CloseIO(dxil_output))
          {
            SDL_free(compiled_dxil_shader);
            SDL_free(file_data);
            std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to close dxil output file for shader {}", resource.path.string())));
            return;
          }
        }
        resource.source_text += "  const compiled_shader " + resource.path.stem().string() +
                                ((resource.path.extension() == ".vert") ? "_vertex" : "_fragment") + " = {\n    {";
        for (size_t index = 0; index < compiled_dxil_size; ++index)
        {
          resource.source_text += csr::utility::unsigned_char_to_hex(compiled_dxil_shader[index]);
          if (index < compiled_dxil_size - 1)
          {
            resource.source_text += ",";
            if ((index + 1) % 16 == 0)
              resource.source_text += "\n     ";
            else
              resource.source_text += " ";
          }
        }
        resource.source_text += "},\n    {";
        SDL_free(compiled_dxil_shader);

        size_t compiled_spirv_size = 0;
        Uint8 *compiled_spirv_shader =
          reinterpret_cast<Uint8 *>(SDL_ShaderCross_CompileSPIRVFromHLSL(&hlsl_info, &compiled_spirv_size));
        if (!compiled_spirv_shader)
        {
          SDL_free(file_data);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(std::make_exception_ptr(
            csr::utility::sdl_exception("Failed to compile spirv shader {}", resource.path.string())));
          return;
        }
        SDL_IOStream *spirv_output = nullptr;
        {
          std::lock_guard<std::mutex> lock(io_mutex);
          spirv_output = SDL_IOFromFile(
            (state.output_shader_directory / resource.path.filename()).string().append(".spv").c_str(), "w");
        }
        if (!spirv_output)
        {
          SDL_free(file_data);
          SDL_free(compiled_spirv_shader);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(std::make_exception_ptr(
            csr::utility::sdl_exception("Failed to open spirv output file for shader {}", resource.path.string())));
          return;
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (SDL_WriteIO(spirv_output, compiled_spirv_shader, compiled_spirv_size) != compiled_spirv_size)
          {
            SDL_free(file_data);
            SDL_free(compiled_spirv_shader);
            SDL_CloseIO(spirv_output);
            std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to write spirv output file for shader {}", resource.path.string())));
            return;
          }
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (!SDL_CloseIO(spirv_output))
          {
            SDL_free(file_data);
            SDL_free(compiled_spirv_shader);
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to close spirv output file for shader {}", resource.path.string())));
            return;
          }
        }
        for (size_t index = 0; index < compiled_spirv_size; ++index)
        {
          resource.source_text += csr::utility::unsigned_char_to_hex(compiled_spirv_shader[index]);
          if (index < compiled_spirv_size - 1)
          {
            resource.source_text += ",";
            if ((index + 1) % 16 == 0)
              resource.source_text += "\n     ";
            else
              resource.source_text += " ";
          }
        }
        resource.source_text += "}};\n";
        SDL_free(compiled_spirv_shader);

        resource.include_text += "  extern const compiled_shader " + resource.path.stem().string() +
                                 ((resource.path.extension() == ".vert") ? "_vertex" : "_fragment") + ";\n";
        SDL_free(file_data);
      }

      if (resource.type == csr::base::resource::TEXTURE)
      {
        int width = 0, height = 0, channels = 0;
        stbi_set_flip_vertically_on_load(true);
        Uint8 *image_data = stbi_load(resource.path.string().c_str(), &width, &height, &channels, 4);
        if (!image_data)
        {
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(
            std::make_exception_ptr(csr::utility::stbi_exception("Failed to load texture {}", resource.path.string())));
          return;
        }

        resource.source_text += "  const compiled_texture " + resource.path.stem().string() + "_texture = {\n    {";
        for (int index = 0; index < width * height * channels; ++index)
        {
          resource.source_text += csr::utility::unsigned_char_to_hex(image_data[index]);
          if (index < width * height * channels - 1)
          {
            resource.source_text += ",";
            if ((index + 1) % 16 == 0)
              resource.source_text += "\n     ";
            else
              resource.source_text += " ";
          }
        }
        stbi_image_free(image_data);

        resource.source_text += "},\n    " + std::to_string(width) + ",\n    " + std::to_string(height) + ",\n    " +
                                std::to_string(channels) + "};\n";
        resource.include_text += "  extern const compiled_texture " + resource.path.stem().string() + "_texture;\n";
      }
    });
  if (!exceptions.empty())
  {
    std::string error_message = "Errors occurred while processing resources:\n";
    for (const std::exception_ptr &exception : exceptions)
    {
      try
      {
        std::rethrow_exception(exception);
      }
      catch (const std::exception &error)
      {
        error_message += "  - " + std::string(error.what()) + "\n";
      }
    }
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::utility::exception(error_message);
  }

  for (const csr::base::resource &resource : state.resources)
  {
    include_content += resource.include_text;
    source_content += resource.source_text;
  }
  include_content += "}";
  source_content += "}";

  const std::array<std::filesystem::path, 2> output_file_paths = {state.output_include_directory / "resource.hpp",
                                                                  state.output_source_directory / "resource.cpp"};
  for (const std::filesystem::path &output_file_path : output_file_paths)
  {
    SDL_IOStream *output_file = nullptr;
    std::string output_content = "";
    if (output_file_path.extension() == ".hpp")
    {
      output_file = SDL_IOFromFile(output_file_paths.at(0).string().c_str(), "w");
      output_content = std::move(include_content);
    }
    else if (output_file_path.extension() == ".cpp")
    {
      output_file = SDL_IOFromFile(output_file_paths.at(1).string().c_str(), "w");
      output_content = std::move(source_content);
    }
    else
    {
      SDL_ShaderCross_Quit();
      SDL_Quit();
      throw csr::utility::exception("Unsupported output file type: " + output_file_path.extension().string());
    }

    if (!output_file)
    {
      SDL_ShaderCross_Quit();
      SDL_Quit();
      throw csr::utility::sdl_exception("Failed to open output file " + output_file_path.string());
    }
    if (SDL_WriteIO(output_file, output_content.c_str(), output_content.size()) != output_content.size())
    {
      SDL_CloseIO(output_file);
      SDL_ShaderCross_Quit();
      SDL_Quit();
      throw csr::utility::sdl_exception("Failed to write output file " + output_file_path.string());
    }
    if (!SDL_CloseIO(output_file))
    {
      SDL_ShaderCross_Quit();
      SDL_Quit();
      throw csr::utility::sdl_exception("Failed to close output file " + output_file_path.string());
    }
  }

  SDL_ShaderCross_Quit();
  SDL_Quit();
  return EXIT_SUCCESS;
}

int main(int argc, char *argv[])
{
  try
  {
    return try_main(argc, argv);
  }
  catch (const std::exception &error)
  {
    std::cerr << "Exception: " << error.what() << std::endl;
    return EXIT_FAILURE;
  }
}
