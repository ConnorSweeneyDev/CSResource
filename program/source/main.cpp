#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <exception>
#include <execution>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <iterator>
#include <mutex>
#include <regex>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include "SDL3/SDL_init.h"
#include "SDL3/SDL_iostream.h"
#include "SDL3/SDL_stdinc.h"
#include "SDL3_shadercross/SDL_shadercross.h"
#include "stb_image.h"

#include "exception.hpp"
#include "state.hpp"
#include "utility.hpp"

int try_main(int argc, char *argv[])
{
  csr::base::state state(argc, argv);

  if (state.task == csr::base::state::COMPILE)
  {
    try
    {
      std::filesystem::create_directories(state.output_shader_directory);
      std::filesystem::create_directories(state.output_include_directory);
      std::filesystem::create_directories(state.output_source_directory);
    }
    catch (const std::exception &error)
    {
      std::string directories =
        std::format("[{}, {}, {}]", state.output_shader_directory.string(), state.output_include_directory.string(),
                    state.output_source_directory.string());
      throw csr::utility::exception("Failed to create output directories " + directories + ": " +
                                    std::string(error.what()));
    }

    if (!SDL_ShaderCross_Init()) throw csr::utility::sdl_exception("Failed to initialize shadercross");

    std::string include_content = "// This file is automatically generated, do not edit manually.\n\n"
                                  "#pragma once\n\n"
                                  "#include <span>\n\n"
                                  "namespace cse::resource\n"
                                  "{\n"
                                  "  struct compiled_shader\n"
                                  "  {\n"
                                  "    const std::span<const unsigned char> dxil = {};\n"
                                  "    const std::span<const unsigned char> spirv = {};\n"
                                  "  };\n"
                                  "  struct compiled_texture\n"
                                  "  {\n"
                                  "    const std::span<const unsigned char> image = {};\n"
                                  "    const unsigned int width = 0;\n"
                                  "    const unsigned int height = 0;\n"
                                  "    const unsigned int channels = 0;\n"
                                  "    const unsigned int frame_width = 0;\n"
                                  "    const unsigned int frame_height = 0;\n"
                                  "    const unsigned int frame_count = 0;\n"
                                  "  };\n\n";
    std::string source_content = "// This file is automatically generated, do not edit manually.\n\n"
                                 "#include \"resource.hpp\"\n\n"
                                 "#include <array>\n"
                                 "#include <span>\n\n"
                                 "namespace cse::resource\n"
                                 "{\n";
    std::vector<std::exception_ptr> exceptions;
    std::mutex exceptions_mutex;
    std::mutex io_mutex;
    std::for_each(
      std::execution::par, state.resources.begin(), state.resources.end(),
      [&state, &exceptions, &exceptions_mutex, &io_mutex](csr::base::resource &resource)
      {
        if (resource.type == csr::base::resource::INVALID)
        {
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(std::make_exception_ptr(
            csr::utility::exception("Invalid resource type for resource: {}", resource.path.string())));
          return;
        }

        if (resource.type == csr::base::resource::SHADER)
        {
          size_t file_size = 0;
          char *file_data = reinterpret_cast<char *>(SDL_LoadFile(resource.path.string().c_str(), &file_size));
          if (!file_data)
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(
              std::make_exception_ptr(csr::utility::sdl_exception("Failed to load shader {}", resource.path.string())));
            return;
          }
          std::string file_content(file_data, file_size);
          SDL_free(file_data);

          const std::string name = resource.path.stem().string();
          const std::string type = (resource.path.extension() == ".vert") ? "vertex" : "fragment";

          SDL_ShaderCross_HLSL_Info hlsl_info(file_content.c_str(), "main", nullptr, nullptr,
                                              (type == "vertex") ? SDL_SHADERCROSS_SHADERSTAGE_VERTEX
                                                                 : SDL_SHADERCROSS_SHADERSTAGE_FRAGMENT,
                                              false, nullptr, 0);

          size_t compiled_dxil_size = 0;
          Uint8 *compiled_dxil_shader =
            reinterpret_cast<Uint8 *>(SDL_ShaderCross_CompileDXILFromHLSL(&hlsl_info, &compiled_dxil_size));
          if (!compiled_dxil_shader)
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to compile dxil shader {}", resource.path.string())));
            return;
          }
          SDL_IOStream *dxil_output = nullptr;
          {
            std::lock_guard<std::mutex> lock(io_mutex);
            dxil_output = SDL_IOFromFile(
              (state.output_shader_directory / resource.path.filename()).string().append(".dxil").c_str(), "w");
          }
          if (!dxil_output)
          {
            SDL_free(compiled_dxil_shader);
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to open dxil output file for shader {}", resource.path.string())));
            return;
          }
          {
            std::lock_guard<std::mutex> io_lock(io_mutex);
            if (SDL_WriteIO(dxil_output, compiled_dxil_shader, compiled_dxil_size) != compiled_dxil_size)
            {
              SDL_free(compiled_dxil_shader);
              SDL_CloseIO(dxil_output);
              std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
              exceptions.emplace_back(std::make_exception_ptr(
                csr::utility::sdl_exception("Failed to write dxil output file for shader {}", resource.path.string())));
              return;
            }
          }
          {
            std::lock_guard<std::mutex> io_lock(io_mutex);
            if (!SDL_CloseIO(dxil_output))
            {
              SDL_free(compiled_dxil_shader);
              std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
              exceptions.emplace_back(std::make_exception_ptr(
                csr::utility::sdl_exception("Failed to close dxil output file for shader {}", resource.path.string())));
              return;
            }
          }
          std::string dxil_data =
            std::vformat("  static constexpr std::array<const unsigned char, {}> {}_{}_dxil = {{\n    ",
                         std::make_format_args(compiled_dxil_size, name, type));
          for (size_t index = 0; index < compiled_dxil_size; ++index)
          {
            dxil_data += csr::utility::unsigned_char_to_hex(compiled_dxil_shader[index]);
            if (index < compiled_dxil_size - 1)
            {
              dxil_data += ",";
              if ((index + 1) % 16 == 0)
                dxil_data += "\n    ";
              else
                dxil_data += " ";
            }
          }
          dxil_data += "};";
          SDL_free(compiled_dxil_shader);

          size_t compiled_spirv_size = 0;
          Uint8 *compiled_spirv_shader =
            reinterpret_cast<Uint8 *>(SDL_ShaderCross_CompileSPIRVFromHLSL(&hlsl_info, &compiled_spirv_size));
          if (!compiled_spirv_shader)
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to compile spirv shader {}", resource.path.string())));
            return;
          }
          SDL_IOStream *spirv_output = nullptr;
          {
            std::lock_guard<std::mutex> lock(io_mutex);
            spirv_output = SDL_IOFromFile(
              (state.output_shader_directory / resource.path.filename()).string().append(".spv").c_str(), "w");
          }
          if (!spirv_output)
          {
            SDL_free(compiled_spirv_shader);
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::sdl_exception("Failed to open spirv output file for shader {}", resource.path.string())));
            return;
          }
          {
            std::lock_guard<std::mutex> io_lock(io_mutex);
            if (SDL_WriteIO(spirv_output, compiled_spirv_shader, compiled_spirv_size) != compiled_spirv_size)
            {
              SDL_free(compiled_spirv_shader);
              SDL_CloseIO(spirv_output);
              std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
              exceptions.emplace_back(std::make_exception_ptr(csr::utility::sdl_exception(
                "Failed to write spirv output file for shader {}", resource.path.string())));
              return;
            }
          }
          {
            std::lock_guard<std::mutex> io_lock(io_mutex);
            if (!SDL_CloseIO(spirv_output))
            {
              SDL_free(compiled_spirv_shader);
              std::lock_guard<std::mutex> lock(exceptions_mutex);
              exceptions.emplace_back(std::make_exception_ptr(csr::utility::sdl_exception(
                "Failed to close spirv output file for shader {}", resource.path.string())));
              return;
            }
          }
          std::string spirv_data =
            std::vformat("  static constexpr std::array<const unsigned char, {}> {}_{}_spirv = {{\n    ",
                         std::make_format_args(compiled_spirv_size, name, type));
          for (size_t index = 0; index < compiled_spirv_size; ++index)
          {
            spirv_data += csr::utility::unsigned_char_to_hex(compiled_spirv_shader[index]);
            if (index < compiled_spirv_size - 1)
            {
              spirv_data += ",";
              if ((index + 1) % 16 == 0)
                spirv_data += "\n    ";
              else
                spirv_data += " ";
            }
          }
          spirv_data += "};";
          SDL_free(compiled_spirv_shader);

          resource.include_text +=
            std::vformat("  extern const compiled_shader {}_{};\n", std::make_format_args(name, type));
          resource.source_text +=
            std::vformat("{}\n{}\n  const compiled_shader {}_{} = {{\n    std::span<const unsigned "
                         "char>({}_{}_dxil),\n    std::span<const unsigned char>({}_{}_spirv)}};\n",
                         std::make_format_args(dxil_data, spirv_data, name, type, name, type, name, type));
        }

        if (resource.type == csr::base::resource::TEXTURE)
        {
          int width = 0, height = 0, channels = 0;
          stbi_set_flip_vertically_on_load(true);
          Uint8 *image_data = stbi_load(resource.path.string().c_str(), &width, &height, &channels, 4);
          if (!image_data)
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::stbi_exception("Failed to load texture {}", resource.path.string())));
            return;
          }

          const int size = width * height * channels;
          const std::string name = resource.path.stem().string();

          std::string image_data_hex =
            std::vformat("  static constexpr std::array<const unsigned char, {}> {}_texture_image = {{\n    ",
                         std::make_format_args(size, name));
          for (int index = 0; index < size; ++index)
          {
            image_data_hex += csr::utility::unsigned_char_to_hex(image_data[index]);
            if (index < size - 1)
            {
              image_data_hex += ",";
              if ((index + 1) % 16 == 0)
                image_data_hex += "\n    ";
              else
                image_data_hex += " ";
            }
          }
          image_data_hex += "};";
          stbi_image_free(image_data);

          std::ifstream png(resource.path, std::ios::binary);
          if (!png)
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::exception("Failed to open texture file for reading {}", resource.path.string())));
            return;
          }
          char buffer[8] = {};
          png.read(buffer, sizeof(buffer));
          if (png.gcount() != sizeof(buffer))
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::exception("Failed to read texture file header {}", resource.path.string())));
            return;
          }

          std::array<unsigned int, 3> frame_data = {};
          std::vector<char> chunk = {};
          bool found_chunk = false;
          while (png.read(buffer, sizeof(buffer)))
          {
            int chunk_length = (static_cast<unsigned char>(buffer[0]) << 24) |
                               (static_cast<unsigned char>(buffer[1]) << 16) |
                               (static_cast<unsigned char>(buffer[2]) << 8) | static_cast<unsigned char>(buffer[3]);
            std::string chunk_type(buffer + 4, buffer + 8);
            if (chunk_type == "cSRe")
            {
              chunk.resize(static_cast<size_t>(chunk_length));
              png.read(chunk.data(), chunk_length);
              std::string comment(chunk.begin(), chunk.end());
              std::regex frame_data_regex(R"(frame_width:\s*(\d+);frame_height:\s*(\d+);frame_count:\s*(\d+);)");
              std::smatch match;
              if (std::regex_search(comment, match, frame_data_regex))
              {
                frame_data[0] = std::stoul(match[1].str());
                frame_data[1] = std::stoul(match[2].str());
                frame_data[2] = std::stoul(match[3].str());
              }
              else
              {
                std::lock_guard<std::mutex> lock(exceptions_mutex);
                exceptions.emplace_back(std::make_exception_ptr(
                  csr::utility::exception("Invalid cSRe png data section {}", resource.path.string())));
                return;
              }
              found_chunk = true;
              break;
            }
            png.seekg(chunk_length + 4, std::ios::cur);
          }
          png.close();
          if (!found_chunk)
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::utility::exception("Invalid cSRe png data section {}", resource.path.string())));
            return;
          }

          if ((static_cast<unsigned int>(width) % frame_data[0] != 0 || frame_data[0] <= 0 ||
               frame_data[0] > static_cast<unsigned int>(width)) ||
              (static_cast<unsigned int>(height) % frame_data[1] != 0 || frame_data[1] <= 0 ||
               frame_data[1] > static_cast<unsigned int>(height)))
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(csr::utility::exception(
              "Texture dimensions must be a multiple of frame dimensions {}", resource.path.string())));
            return;
          }
          if (frame_data[2] <= 0 || frame_data[2] > ((static_cast<unsigned int>(width) / frame_data[0]) *
                                                     (static_cast<unsigned int>(height) / frame_data[1])))
          {
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(csr::utility::exception(
              "Texture frame count must be greater than 0 and less than or equal to total possible frames {}",
              resource.path.string())));
            return;
          }

          resource.include_text +=
            std::vformat("  extern const compiled_texture {}_texture;\n", std::make_format_args(name));
          resource.source_text +=
            std::vformat("{}\n  const compiled_texture {}_texture = {{\n    std::span<const unsigned "
                         "char>({}_texture_image), {}, {}, {}, {}, {}, {}}};\n",
                         std::make_format_args(image_data_hex, name, name, width, height, channels, frame_data[0],
                                               frame_data[1], frame_data[2]));
        }
      });
    if (!exceptions.empty())
    {
      std::string error_message = "Errors occurred while processing resources:";
      for (const std::exception_ptr &exception : exceptions)
      {
        try
        {
          std::rethrow_exception(exception);
        }
        catch (const std::exception &error)
        {
          error_message += "\n  - " + std::string(error.what());
        }
      }
      SDL_ShaderCross_Quit();
      SDL_Quit();
      throw csr::utility::exception(error_message);
    }

    for (const csr::base::resource &resource : state.resources)
    {
      include_content += resource.include_text;
      source_content += resource.source_text;
    }
    include_content += "}";
    source_content += "}";

    const std::array<std::filesystem::path, 2> output_file_paths = {state.output_include_directory / "resource.hpp",
                                                                    state.output_source_directory / "resource.cpp"};
    for (const std::filesystem::path &output_file_path : output_file_paths)
    {
      SDL_IOStream *output_file = nullptr;
      std::string output_content = "";
      if (output_file_path.extension() == ".hpp")
      {
        output_file = SDL_IOFromFile(output_file_paths.at(0).string().c_str(), "w");
        output_content = std::move(include_content);
      }
      else if (output_file_path.extension() == ".cpp")
      {
        output_file = SDL_IOFromFile(output_file_paths.at(1).string().c_str(), "w");
        output_content = std::move(source_content);
      }
      else
      {
        SDL_ShaderCross_Quit();
        SDL_Quit();
        throw csr::utility::exception("Unsupported output file type: " + output_file_path.extension().string());
      }

      if (!output_file)
      {
        SDL_ShaderCross_Quit();
        SDL_Quit();
        throw csr::utility::sdl_exception("Failed to open output file " + output_file_path.string());
      }
      if (SDL_WriteIO(output_file, output_content.c_str(), output_content.size()) != output_content.size())
      {
        SDL_CloseIO(output_file);
        SDL_ShaderCross_Quit();
        SDL_Quit();
        throw csr::utility::sdl_exception("Failed to write output file " + output_file_path.string());
      }
      if (!SDL_CloseIO(output_file))
      {
        SDL_ShaderCross_Quit();
        SDL_Quit();
        throw csr::utility::sdl_exception("Failed to close output file " + output_file_path.string());
      }
    }

    SDL_ShaderCross_Quit();
    SDL_Quit();
  }
  else if (state.task == csr::base::state::LIST)
  {
    if (!std::filesystem::exists(state.texture_directory) || !std::filesystem::is_directory(state.texture_directory))
      throw csr::utility::exception("Texture directory does not exist or is not a valid directory {}",
                                    state.texture_directory.string());

    std::unordered_map<std::string, std::array<unsigned int, 3>> frame_data = {};
    for (const auto &entry : std::filesystem::recursive_directory_iterator(state.texture_directory))
    {
      if (entry.is_regular_file() && entry.path().extension() == ".png")
      {
        std::ifstream png(entry.path(), std::ios::binary);
        if (!png) throw csr::utility::exception("Failed to open texture file for reading {}", entry.path().string());
        char buffer[8] = {};
        png.read(buffer, sizeof(buffer));
        if (png.gcount() != sizeof(buffer))
          throw csr::utility::exception("Failed to read texture file header {}", entry.path().string());

        std::vector<char> chunk = {};
        bool found_chunk = false;
        while (png.read(buffer, sizeof(buffer)))
        {
          int chunk_length = (static_cast<unsigned char>(buffer[0]) << 24) |
                             (static_cast<unsigned char>(buffer[1]) << 16) |
                             (static_cast<unsigned char>(buffer[2]) << 8) | static_cast<unsigned char>(buffer[3]);
          std::string chunk_type(buffer + 4, buffer + 8);
          if (chunk_type == "cSRe")
          {
            chunk.resize(static_cast<size_t>(chunk_length));
            png.read(chunk.data(), chunk_length);
            std::string comment(chunk.begin(), chunk.end());
            std::regex frame_data_regex(R"(frame_width:\s*(\d+);frame_height:\s*(\d+);frame_count:\s*(\d+);)");
            std::smatch match;
            if (std::regex_search(comment, match, frame_data_regex))
              frame_data[entry.path().string()] = {std::stoul(match[1].str()), std::stoul(match[2].str()),
                                                   std::stoul(match[3].str())};
            else
              throw csr::utility::exception("Invalid cSRe png data section {}", entry.path().string());
            found_chunk = true;
            break;
          }
          png.seekg(chunk_length + 4, std::ios::cur);
        }
        if (!found_chunk) frame_data[entry.path().string()] = {0, 0, 0};
        png.close();
      }
    }
    for (const auto &entry : frame_data)
      if (entry.second != std::array<unsigned int, 3>{0, 0, 0})
        std::cout << std::format("{}: {}x{} {}f", entry.first, entry.second[0], entry.second[1], entry.second[2])
                  << std::endl;
    for (const auto &entry : frame_data)
      if (entry.second == std::array<unsigned int, 3>{0, 0, 0})
        std::cout << std::format("{}: NULL", entry.first) << std::endl;
  }
  else if (state.task == csr::base::state::SET)
  {
    std::ifstream png_in(state.texture_path, std::ios::binary);
    if (!png_in)
      throw csr::utility::exception("Failed to open texture file for reading {}", state.texture_path.string());
    std::vector<char> file_data((std::istreambuf_iterator<char>(png_in)), std::istreambuf_iterator<char>());
    png_in.close();

    std::string chunk_type = "cSRe";
    size_t pos = 8;
    while (pos < file_data.size())
    {
      if (pos + 8 > file_data.size()) break;
      uint32_t chunk_length = static_cast<uint32_t>(
        (static_cast<unsigned char>(file_data[pos]) << 24) | (static_cast<unsigned char>(file_data[pos + 1]) << 16) |
        (static_cast<unsigned char>(file_data[pos + 2]) << 8) | static_cast<unsigned char>(file_data[pos + 3]));

      if (pos + 8 + chunk_length + 4 > file_data.size())
        throw csr::utility::exception("Invalid PNG file, chunk length exceeds file size {}",
                                      state.texture_path.string());

      std::string current_chunk_type(file_data.begin() + static_cast<long long>(pos) + 4,
                                     file_data.begin() + static_cast<long long>(pos) + 8);
      if (current_chunk_type == chunk_type)
      {
        file_data.erase(file_data.begin() + static_cast<long long>(pos),
                        file_data.begin() + static_cast<long long>(pos) + 8 + chunk_length + 4);
        break;
      }

      pos += static_cast<size_t>(8 + chunk_length + 4);
    }

    size_t iend_pos = std::string::npos;
    for (size_t index = file_data.size() >= 12 ? file_data.size() - 12 : 0; index < file_data.size() - 7; ++index)
      if (file_data[index] == 0 && file_data[index + 1] == 0 && file_data[index + 2] == 0 &&
          file_data[index + 3] == 0 && file_data[index + 4] == 'I' && file_data[index + 5] == 'E' &&
          file_data[index + 6] == 'N' && file_data[index + 7] == 'D')
      {
        iend_pos = index + 4;
        break;
      }
    if (iend_pos == std::string::npos)
      throw csr::utility::exception("Invalid PNG file, IEND chunk not found {}", state.texture_path.string());

    std::string chunk_data = std::format("frame_width:{};frame_height:{};frame_count:{};", state.frame_width,
                                         state.frame_height, state.frame_count);
    std::vector<unsigned char> custom_chunk;
    uint32_t chunk_length = static_cast<uint32_t>(chunk_data.size());
    custom_chunk.push_back((chunk_length >> 24) & 0xFF);
    custom_chunk.push_back((chunk_length >> 16) & 0xFF);
    custom_chunk.push_back((chunk_length >> 8) & 0xFF);
    custom_chunk.push_back(chunk_length & 0xFF);

    custom_chunk.insert(custom_chunk.end(), chunk_type.begin(), chunk_type.end());
    custom_chunk.insert(custom_chunk.end(), chunk_data.begin(), chunk_data.end());

    uint32_t crc =
      csr::utility::calculate_crc(std::vector<unsigned char>(custom_chunk.begin() + 4, custom_chunk.end()));
    custom_chunk.push_back((crc >> 24) & 0xFF);
    custom_chunk.push_back((crc >> 16) & 0xFF);
    custom_chunk.push_back((crc >> 8) & 0xFF);
    custom_chunk.push_back(crc & 0xFF);

    file_data.insert(file_data.begin() + static_cast<long long>(iend_pos) - 4, custom_chunk.begin(),
                     custom_chunk.end());

    std::ofstream png_out(state.texture_path, std::ios::binary);
    if (!png_out)
      throw csr::utility::exception("Failed to open texture file for writing {}", state.texture_path.string());
    png_out.write(file_data.data(), static_cast<long long>(file_data.size()));
    png_out.close();
  }
  else
    throw csr::utility::exception("Invalid task specified. Use 'compile', 'list', or 'set'.");

  return EXIT_SUCCESS;
}

int main(int argc, char *argv[])
{
  try
  {
    return try_main(argc, argv);
  }
  catch (const std::exception &error)
  {
    std::cerr << "Exception: " << error.what() << std::endl;
    return EXIT_FAILURE;
  }
}
