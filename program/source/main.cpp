#include <algorithm>
#include <cstddef>
#include <cstdlib>
#include <exception>
#include <execution>
#include <filesystem>
#include <format>
#include <iostream>
#include <mutex>
#include <string>
#include <vector>

#include "SDL3/SDL_init.h"
#include "SDL3/SDL_iostream.h"
#include "SDL3/SDL_stdinc.h"
#include "SDL3_shadercross/SDL_shadercross.h"

#include "exception.hpp"
#include "state.hpp"
#include "utility.hpp"

int try_main(int argc, char *argv[])
{
  csr::state state(argc, argv);

  try
  {
    std::filesystem::create_directories(state.output_shader_directory);
    std::filesystem::create_directories(state.output_include_directory);
    std::filesystem::create_directories(state.output_source_directory);
  }
  catch (const std::exception &error)
  {
    std::string directories =
      std::format("[{}, {}, {}]", state.output_shader_directory.string(), state.output_include_directory.string(),
                  state.output_source_directory.string());
    throw csr::exception("Failed to create output directories " + directories + ": " + std::string(error.what()));
  }

  if (!SDL_ShaderCross_Init()) throw csr::sdl_exception("Failed to initialize shadercross");

  std::string include_content = "// This file is automatically generated, do not edit manually.\n\n"
                                "#pragma once\n\n"
                                "#include <vector>\n\n"
                                "namespace cse::resource\n"
                                "{\n"
                                "  struct compiled_shader\n"
                                "  {\n"
                                "    const std::vector<unsigned char> dxil;\n"
                                "    const std::vector<unsigned char> spirv;\n"
                                "  };\n\n";
  std::string source_content = "// This file is automatically generated, do not edit manually.\n\n"
                               "#include \"resource.hpp\"\n\n"
                               "namespace cse::resource\n"
                               "{\n";
  std::vector<std::exception_ptr> exceptions;
  std::mutex exceptions_mutex;
  std::mutex io_mutex;
  std::for_each(
    std::execution::par, state.resources.begin(), state.resources.end(),
    [&state, &exceptions, &exceptions_mutex, &io_mutex](csr::resource &resource)
    {
      if (resource.type == csr::resource::INVALID)
      {
        std::lock_guard<std::mutex> lock(exceptions_mutex);
        exceptions.emplace_back(
          std::make_exception_ptr(csr::exception("Invalid resource type for resource: " + resource.path.string())));
        return;
      }

      if (resource.type == csr::resource::TEXTURE)
      {
        std::lock_guard<std::mutex> lock(exceptions_mutex);
        exceptions.emplace_back(std::make_exception_ptr(
          csr::exception("Texture resources are not implemented yet: " + resource.path.string())));
        return;
      }

      if (resource.type == csr::resource::SHADER)
      {
        size_t file_size = 0;
        char *file_data = reinterpret_cast<char *>(SDL_LoadFile(resource.path.string().c_str(), &file_size));
        if (!file_data)
        {
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(
            std::make_exception_ptr(csr::sdl_exception("Failed to load shader " + resource.path.string())));
          return;
        }

        SDL_ShaderCross_HLSL_Info hlsl_info = {reinterpret_cast<char *>(file_data),
                                               "main",
                                               nullptr,
                                               nullptr,
                                               resource.path.extension() == ".vert"
                                                 ? SDL_SHADERCROSS_SHADERSTAGE_VERTEX
                                                 : SDL_SHADERCROSS_SHADERSTAGE_FRAGMENT,
                                               false,
                                               nullptr,
                                               0};

        size_t compiled_dxil_size = 0;
        Uint8 *compiled_dxil_shader =
          reinterpret_cast<Uint8 *>(SDL_ShaderCross_CompileDXILFromHLSL(&hlsl_info, &compiled_dxil_size));
        if (!compiled_dxil_shader)
        {
          SDL_free(file_data);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(
            std::make_exception_ptr(csr::sdl_exception("Failed to compile dxil shader " + resource.path.string())));
          return;
        }
        SDL_IOStream *dxil_output = nullptr;
        {
          std::lock_guard<std::mutex> lock(io_mutex);
          dxil_output = SDL_IOFromFile(
            (state.output_shader_directory / resource.path.filename()).string().append(".dxil").c_str(), "w");
        }
        if (!dxil_output)
        {
          SDL_free(file_data);
          SDL_free(compiled_dxil_shader);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(std::make_exception_ptr(
            csr::sdl_exception("Failed to open dxil output file for shader " + resource.path.string())));
          return;
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (SDL_WriteIO(dxil_output, compiled_dxil_shader, compiled_dxil_size) != compiled_dxil_size)
          {
            SDL_free(file_data);
            SDL_free(compiled_dxil_shader);
            SDL_CloseIO(dxil_output);
            std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::sdl_exception("Failed to write dxil output file for shader " + resource.path.string())));
            return;
          }
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (!SDL_CloseIO(dxil_output))
          {
            SDL_free(compiled_dxil_shader);
            SDL_free(file_data);
            std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::sdl_exception("Failed to close dxil output file for shader " + resource.path.string())));
            return;
          }
        }
        resource.source_text += "  const compiled_shader " + resource.path.stem().string() +
                                ((resource.path.extension() == ".vert") ? "_vertex" : "_fragment") + " = {\n    {";
        for (size_t index = 0; index < compiled_dxil_size; ++index)
        {
          resource.source_text += csr::unsigned_char_to_hex(compiled_dxil_shader[index]);
          if (index < compiled_dxil_size - 1)
          {
            resource.source_text += ",";
            if ((index + 1) % 16 == 0)
              resource.source_text += "\n     ";
            else
              resource.source_text += " ";
          }
        }
        resource.source_text += "},\n    {";
        SDL_free(compiled_dxil_shader);

        size_t compiled_spirv_size = 0;
        Uint8 *compiled_spirv_shader =
          reinterpret_cast<Uint8 *>(SDL_ShaderCross_CompileSPIRVFromHLSL(&hlsl_info, &compiled_spirv_size));
        if (!compiled_spirv_shader)
        {
          SDL_free(file_data);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(
            std::make_exception_ptr(csr::sdl_exception("Failed to compile spirv shader " + resource.path.string())));
          return;
        }
        SDL_IOStream *spirv_output = nullptr;
        {
          std::lock_guard<std::mutex> lock(io_mutex);
          spirv_output = SDL_IOFromFile(
            (state.output_shader_directory / resource.path.filename()).string().append(".spv").c_str(), "w");
        }
        if (!spirv_output)
        {
          SDL_free(file_data);
          SDL_free(compiled_spirv_shader);
          std::lock_guard<std::mutex> lock(exceptions_mutex);
          exceptions.emplace_back(std::make_exception_ptr(
            csr::sdl_exception("Failed to open spirv output file for shader " + resource.path.string())));
          return;
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (SDL_WriteIO(spirv_output, compiled_spirv_shader, compiled_spirv_size) != compiled_spirv_size)
          {
            SDL_free(file_data);
            SDL_free(compiled_spirv_shader);
            SDL_CloseIO(spirv_output);
            std::lock_guard<std::mutex> exception_lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::sdl_exception("Failed to write spirv output file for shader " + resource.path.string())));
            return;
          }
        }
        {
          std::lock_guard<std::mutex> io_lock(io_mutex);
          if (!SDL_CloseIO(spirv_output))
          {
            SDL_free(file_data);
            SDL_free(compiled_spirv_shader);
            std::lock_guard<std::mutex> lock(exceptions_mutex);
            exceptions.emplace_back(std::make_exception_ptr(
              csr::sdl_exception("Failed to close spirv output file for shader " + resource.path.string())));
            return;
          }
        }
        for (size_t index = 0; index < compiled_spirv_size; ++index)
        {
          resource.source_text += csr::unsigned_char_to_hex(compiled_spirv_shader[index]);
          if (index < compiled_spirv_size - 1)
          {
            resource.source_text += ",";
            if ((index + 1) % 16 == 0)
              resource.source_text += "\n     ";
            else
              resource.source_text += " ";
          }
        }
        resource.source_text += "}};\n";
        SDL_free(compiled_spirv_shader);

        resource.include_text += "  extern const compiled_shader " + resource.path.stem().string() +
                                 ((resource.path.extension() == ".vert") ? "_vertex" : "_fragment") + ";\n";
        SDL_free(file_data);
      }
    });
  if (!exceptions.empty())
  {
    std::string error_message = "Errors occurred while processing resources:\n";
    for (const std::exception_ptr &exception : exceptions)
    {
      try
      {
        std::rethrow_exception(exception);
      }
      catch (const std::exception &error)
      {
        error_message += "  - " + std::string(error.what()) + "\n";
      }
    }
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::exception(error_message);
  }

  for (const csr::resource &resource : state.resources)
  {
    include_content += resource.include_text;
    source_content += resource.source_text;
  }
  include_content += "}";
  source_content += "}";

  SDL_IOStream *include_output =
    SDL_IOFromFile((state.output_include_directory / "resource.hpp").string().c_str(), "w");
  if (!include_output)
  {
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::sdl_exception("Failed to open include output file" + state.output_include_directory.string() +
                             "/resource.hpp");
  }
  if (SDL_WriteIO(include_output, include_content.c_str(), include_content.size()) != include_content.size())
  {
    SDL_CloseIO(include_output);
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::sdl_exception("Failed to write include output file " + state.output_include_directory.string() +
                             "/resource.hpp");
  }
  if (!SDL_CloseIO(include_output))
  {
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::sdl_exception("Failed to close include output file " + state.output_include_directory.string() +
                             "/resource.hpp");
  }

  SDL_IOStream *source_output = SDL_IOFromFile((state.output_source_directory / "resource.cpp").string().c_str(), "w");
  if (!source_output)
  {
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::sdl_exception("Failed to open source output file " + state.output_source_directory.string() +
                             "/resource.cpp");
  }
  if (SDL_WriteIO(source_output, source_content.c_str(), source_content.size()) != source_content.size())
  {
    SDL_CloseIO(source_output);
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::sdl_exception("Failed to write source output file " + state.output_source_directory.string() +
                             "/resource.cpp");
  }
  if (!SDL_CloseIO(source_output))
  {
    SDL_ShaderCross_Quit();
    SDL_Quit();
    throw csr::sdl_exception("Failed to close source output file " + state.output_source_directory.string() +
                             "/resource.cpp");
  }

  SDL_ShaderCross_Quit();
  SDL_Quit();
  return EXIT_SUCCESS;
}

int main(int argc, char *argv[])
{
  try
  {
    return try_main(argc, argv);
  }
  catch (const std::exception &error)
  {
    std::cerr << "Exception: " << error.what() << std::endl;
    return EXIT_FAILURE;
  }
}
